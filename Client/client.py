import pickle
import socket
import threading
import time

from Cryptodome.Cipher import AES
from Cryptodome.Hash import SHA3_256
from Cryptodome.Random.random import randrange
from Cryptodome.Util import Padding

from Util.prime_helper import PrimeHelper


# TODO: Make sure to replace prime.bin with larger prime

class UDPClient(object):
    """
    Connect to Server, send/receive data
    """

    def __init__(self, host: str, port: int):
        self.host = host
        self.port = port

        # setup socket to send and receive data
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.sock.bind(("localhost", 0))  # bind socket to local host and any available port

        # read prime for use in key exchange
        self.prime_dump = "data/prime.bin"
        self.helper = PrimeHelper(self.prime_dump)
        self.helper.read()

        # setup event to pause receiving thread during key exchange
        self.wait = threading.Event()
        self.conn_accepted = False

        self.cipher = None
        self.key = None
        
        # send message to signal server to add client to client list
        self.send_message("New Client")

    def set_key(self, key: bytes, nonce: bytes = None):
        """
        Helper function to setup cipher and store on instance

        If nonce is not specified it will be generated by the cipher
        """
        self.cipher = AES.new(key, AES.MODE_EAX, nonce=nonce)

    # dunder functions to allow with ... as ... paradigm
    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.close()

    @staticmethod
    def int_to_bytes(num: int) -> bytes:
        """
        Helper function to convert integer to bytes representation
        """
        return num.to_bytes((num.bit_length() + 7) // 8, "big")

    @staticmethod
    def hash_password(password):
        return SHA3_256.new(password)

    def dh_key_exchange(self, originator: bool = True) -> SHA3_256:
        """
        Facilitates both sides of a basic Diffie-Hellman key exchange and generates a shared secret, the hash of this
        secret is returned to be used as a key for the cipher
        """

        # TODO: Fix key exchange. Probably by keeping a key for every other user.
        if originator:
            timeout = 0
            secret = randrange(1, self.helper.prime)  # Random integer between 1 and prime - 1: to be kept secret

            public = (self.helper.root ** secret) % self.helper.prime  # Public part, shared in the clear

            self.send_message("Request Key Exchange")

            # Timeout connection so it can be retried or cancelled
            while not self.conn_accepted:
                if timeout > 10:
                    raise TimeoutError("Connection timed out")
                time.sleep(1)

                timeout += 1

            self.send_tuple((str(self.helper.prime), str(self.helper.root), str(public)))  # Send public information

            response = int(self.receive_single())

            self.wait.set()

            # Calculate and return shared secret
            return SHA3_256.new(self.int_to_bytes((response ** secret) % self.helper.prime))
        else:
            self.send_message("Key Exchange Accepted")
            prime = int(self.receive_single())
            root = int(self.receive_single())
            response = int(self.receive_single())  # Receive public information

            secret = randrange(1, prime)  # Random integer between 1 and prime - 1: to be kept secret

            public = (root ** secret) % prime  # Public part, shared in the clear

            self.send_message(str(public))  # Send public information

            # Calculate and return shared secret
            return SHA3_256.new(self.int_to_bytes((response ** secret) % self.helper.prime))

    def encrypt(self, key: bytes, plaintext: bytes, nonce: bytes = None) -> (bytes, bytes, bytes):
        """
        Encrypts input text with input key and nonce using cipher specified on the instance and generates a tag that
        can be used to verify message integrity

        Returns a tuple with the encrypted text, hash for checking integrity, and nonce
        """
        # Setup cipher
        self.set_key(key, nonce)

        # Get randomly generated nonce from cipher if not specified
        if nonce is None:
            nonce = self.cipher.nonce

        ciphertext, tag = self.cipher.encrypt_and_digest(Padding.pad(plaintext, 16))
        return ciphertext, tag, nonce

    def decrypt(self, key: bytes, ciphertext: bytes, tag: bytes, nonce: bytes) -> bytes:
        """
        Decrypts encrypted text with cipher specified on the instance and checks tag to verify message integrity
        """
        # Setup cipher
        self.set_key(key, nonce)

        plaintext = Padding.unpad(self.cipher.decrypt(ciphertext), 16)

        # Verify message integrity
        try:
            self.cipher.verify(tag)
        except ValueError:
            print("WARNING: Message Corrupted!")

        return plaintext

    def send_message(self, msg: str):
        """
        Sends encoded message to host address specified on the instance
        """
        self.sock.sendto(bytes(msg, "utf-8"), (self.host, self.port))

    def send_tuple(self, tup: tuple):
        """
        Pickles tuple then sends to host address specified on the instance
        """
        self.sock.sendto(pickle.dumps(tup), (self.host, self.port))

    def send_encrypted_message(self, msg: str):
        """
        Encrypts and sends message if key is established or begins key exchange if no key exists
        """
        if msg.startswith("~"):
            self.send_message(msg[1:])
            if msg == "~Register" or msg == "~Login":
                self.login()
        elif self.key is not None:
            self.send_tuple(self.encrypt(self.key, bytes(msg, "utf-8")))
        else:
            # Recursively attempts to conduct key exchange and send message
            try:
                self.key = self.dh_key_exchange().digest()
                self.send_tuple(self.encrypt(self.key, bytes(msg, "utf-8")))
            except TimeoutError:
                print(f"Connection timed out, resending message '{msg}'...")
                # self.send_encrypted_message(msg)

    @staticmethod
    def prompt():
        print("Enter Username")
        username = input("=> ")

        print("Enter Password")
        password = input("=> ")

        return username, password

    def login(self):
        username, password = self.prompt()
        hashed = SHA3_256.new(bytes(password, "utf-8")).hexdigest()

        self.send_encrypted_message(username)
        self.send_encrypted_message(hashed)

    def format(self, msg: bytes) -> str:
        """
        Decrypts and decodes encrypted messages, decodes non-encrypted messages
        """
        try:
            return str(msg, "utf-8")
        except UnicodeDecodeError:
            return str(self.decrypt(self.key, *(pickle.loads(msg))), "utf-8")

    def receive_single(self) -> str:
        """
        Blocks until a message is received on the socket, returns decoded text
        """
        return self.format(self.sock.recv(1024))

    def receive_forever(self, event):
        """
        Prints data received from Server. To be run in a separate
        daemon thread.
        """
        while True:
            received = self.format(self.sock.recv(1024))

            if received == "Request Key Exchange":
                self.key = self.dh_key_exchange(originator=False).digest()
            elif received == "Key Exchange Accepted":
                self.conn_accepted = True
                event.wait()
            else:
                print(received)

    def close(self):
        """
        Shuts down client gracefully, usually called from the __exit__ method
        """
        self.sock.close()


if __name__ == "__main__":
    HOST, PORT = "localhost", 9999

    with UDPClient(HOST, PORT) as client:
        receive_thread = threading.Thread(target=client.receive_forever, args=(client.wait,))
        receive_thread.daemon = True
        receive_thread.start()

        while True:
            client.send_encrypted_message(input("=> "))
